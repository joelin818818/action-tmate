name: 在最新Ubuntu上运行脚本并循环检查网络 (通过OpenVPN)

on:
  workflow_dispatch: # 手动触发

jobs:
  run-on-ubuntu:
    runs-on: ubuntu-latest # 使用最新的Ubuntu运行器
    timeout-minutes: 60 # 作业超时时间，防止无限循环导致作业一直运行

    steps:
      - name: 检出代码
        uses: actions/checkout@v4 # 检出你的代码仓库

      # --- 合并后的步骤：并发连接OpenVPN、运行脚本、循环检查网络 ---
      - name: 并发：连接OpenVPN、验证出口IP并循环检查网络 (脚本稍后运行)
        run: |
          #!/bin/bash
          # 主脚本层面不使用 set -e，以便手动处理后台任务的成功/失败
          # set -u # 可选，如果需要检查未定义变量
          # set -x # 可选，但并发时日志会非常混乱

          # --- 全局变量和清理 ---
          VPN_START_PID=""
          SCRIPT_RUN_PID="" # 现在脚本任务不是立即后台启动，所以这个PID可能不用于wait
          NET_CHECK_PID=""
          # OpenVPN守护进程的PID文件 (由 --writepid 生成)
          OPENVPN_DAEMON_PID_FILE="/tmp/openvpn_daemon.pid" # 更改文件名避免冲突
          # 自动检测到的VPN接口名称 (在这个验证逻辑下可能不被设置或不重要)
          DETECTED_VPN_IFACE=""

          # 清理后台进程的函数
          cleanup_processes() {
              echo "--- 清理后台进程 ---"
               # 尝试停止网络检查循环任务 (如果在后台运行)
              if [ -n "$NET_CHECK_PID" ] && ps -p "$NET_CHECK_PID" > /dev/null 2>&1; then
                  echo "尝试停止网络检查进程 (PID: $NET_CHECK_PID)..."
                  kill "$NET_CHECK_PID" || true # kill可能会失败，使用 || true 忽略错误
              fi
               # 注意：SCRIPT_RUN_PID 在新的主逻辑中可能不是后台进程，清理时要注意
              # 尝试停止脚本运行任务 (如果它还在运行并且是后台进程)
              # if [ -n "$SCRIPT_RUN_PID" ] && ps -p "$SCRIPT_RUN_PID" > /dev/null 2>&1; then
              #     echo "尝试停止脚本运行进程 (PID: $SCRIPT_RUN_PID)..."
              #     kill "$SCRIPT_RUN_PID" || true
              # fi
              # 尝试停止VPN启动函数进程 (如果它还在等待OpenVPN守护进程启动)
              if [ -n "$VPN_START_PID" ] && ps -p "$VPN_START_PID" > /dev/null 2>&1; then
                  echo "尝试停止VPN启动函数进程 (PID: $VPN_START_PID)..."
                  kill "$VPN_START_PID" || true
              fi

              # 尝试停止OpenVPN守护进程本身 (通过其PID文件)
              if [ -f "${OPENVPN_DAEMON_PID_FILE}" ] && ps -p "$(cat ${OPENVPN_DAEMON_PID_FILE} 2>/dev/null)" > /dev/null 2>&1; then
                  OPENVPN_DAEMON_PID=$(cat ${OPENVPN_DAEMON_PID_FILE})
                  echo "尝试停止OpenVPN守护进程 (PID: $OPENVPN_DAEMON_PID)..."
                  # 发送SIGTERM，让OpenVPN优雅退出
                  sudo kill "$OPENVPN_DAEMON_PID" || true
                  sleep 2 # 等待几秒让其退出
                  # 如果进程仍未退出，尝试SIGKILL
                  if ps -p "$OPENVPN_DAEMON_PID" > /dev/null 2>&1; then
                      echo "OpenVPN守护进程 (PID: $OPENVPN_DAEMON_PID) 未能正常停止，尝试强制停止 (SIGKILL)..."
                      sudo kill -9 "$OPENVPN_DAEMON_PID" || true
                  fi
                  # 清理PID文件
                  sudo rm -f "${OPENVPN_DAEMON_PID_FILE}" || true
              fi
              echo "--- 清理完成 ---"
          }

          # 设置 trap，在脚本退出时（无论成功或失败）执行 cleanup_processes 函数
          trap cleanup_processes EXIT

          # --- OpenVPN 连接与验证函数 (通过检查出口IP国家) ---
          connect_vpn_and_verify() {
              # 在此函数 (子shell) 内部启用 set -eux
              set -eux
              echo "--- [VPN任务] 开始连接 OpenVPN ---"
              local OPENVPN_CONFIG_CONTENT="${{ secrets.OPENVPN_CONFIG }}"
              local CONFIG_DIR="/etc/openvpn/client"
              local CONFIG_FILE="${CONFIG_DIR}/client.conf"
              # 使用函数外部定义的全局PID文件路径
              local PID_FILE="${OPENVPN_DAEMON_PID_FILE}"

              echo "[VPN任务] 安装 OpenVPN 软件包..."
              if ! dpkg -s openvpn > /dev/null 2>&1; then
                sudo apt-get update
                sudo apt-get install -y openvpn
              else
                echo "[VPN任务] OpenVPN 软件包已安装."
              fi

              echo "[VPN任务] 创建配置目录: ${CONFIG_DIR}"
              sudo mkdir -p "${CONFIG_DIR}"
              sudo chmod 700 "${CONFIG_DIR}"

              echo "[VPN任务] 创建 OpenVPN 配置文件: ${CONFIG_FILE} (从 Secret)"
              echo "${OPENVPN_CONFIG_CONTENT}" | sudo sh -c "cat > ${CONFIG_FILE}"
              sudo chmod 600 "${CONFIG_FILE}"

              echo "[VPN任务] 启动 OpenVPN 客户端 (后台运行，PID写入 ${PID_FILE})..."
              # 注意: sudo openvpn 命令本身会fork一个守护进程。这里的 '&' 是为了让此 openvpn 命令的*启动*不阻塞父脚本。
              # 我们依赖 --writepid 和后续的 ps 检查来确认 OpenVPN 守护进程的状态。
              # --- 这里添加了 --verb 3 参数来控制 OpenVPN 的日志输出 ---
              sudo openvpn --config "${CONFIG_FILE}" --writepid "${PID_FILE}" --verb 3 &
              # 重要：OpenVPN 守护进程的 PID 会被写入 PID_FILE，而不是 $!。
              # 此处的 $! 是 sudo openvpn 这个父进程（非守护进程）的PID，它会很快退出。

              echo "[VPN任务] 等待 OpenVPN 守护进程启动并写入 PID (最多 10 秒)..."
              local WAIT_PID_TIMEOUT=10
              local END_WAIT_PID=$((SECONDS + WAIT_PID_TIMEOUT))
              while [ $SECONDS -lt $END_WAIT_PID ]; do
                  if [ -f "${PID_FILE}" ] && [ -s "${PID_FILE}" ]; then
                      OPENVPN_DAEMON_PID=$(cat ${PID_FILE})
                      if ps -p "$OPENVPN_DAEMON_PID" > /dev/null 2>&1; then
                          echo "[VPN任务] OpenVPN 守护进程已启动，PID: $OPENVPN_DAEMON_PID."
                          break
                      fi
                  fi
                  sleep 1
              done

              if [ ! -f "${PID_FILE}" ] || ! [ -s "${PID_FILE}" ] || ! ps -p "$(cat ${PID_FILE} 2>/dev/null)" > /dev/null 2>&1; then
                  echo "[VPN任务] ✗ 在 ${WAIT_PID_TIMEOUT} 秒内未检测到有效的 OpenVPN 守护进程 PID 或进程未运行。"
                  # 触发 cleanup trap 并退出
                  exit 1
              fi


              echo "[VPN任务] 验证出口IP国家..."
              # --- 增加超时时间到 300 秒 (5分钟) ---
              local TIMEOUT_SECONDS=300
              local END_TIME=$((SECONDS + TIMEOUT_SECONDS))
              # --- 期望的出口国家代码 ---
              local TARGET_COUNTRY_CODE="CN"
              # --- 获取出口IP国家的服务 URL ---
              # 可以选择其他服务，例如：
              # https://ip.gs/country
              # https://ipapi.co/country
              local IP_COUNTRY_SERVICE_URL="https://ipinfo.io/country"


              while [ $SECONDS -lt $END_TIME ]; do
                # 检查 OpenVPN 守护进程是否仍在运行 (通过PID文件)
                if ! ( [ -f "${PID_FILE}" ] && ps -p "$(cat ${PID_FILE} 2>/dev/null)" > /dev/null ); then
                  echo "[VPN任务] ✗ OpenVPN 守护进程 (PID 文件: ${PID_FILE}) 似乎已意外退出。"
                  exit 1 # 表示此函数失败，触发 cleanup trap
                fi

                echo "[VPN任务] 尝试获取出口IP国家并验证 (${TARGET_COUNTRY_CODE})... 剩余 $((END_TIME - SECONDS)) 秒"

                local current_country=""
                # 使用 curl 获取出口国家代码，--fail 确保网络不通或服务返回非2xx时失败
                # 将 stderr 重定向到 /dev/null，只关心 stdout
                if current_country=$(curl -sS --fail --max-time 10 "$IP_COUNTRY_SERVICE_URL" 2>/dev/null); then
                    echo "[VPN任务] 检测到的出口IP国家: ${current_country}"
                    if [ "$current_country" = "$TARGET_COUNTRY_CODE" ]; then
                        echo "[VPN任务] ✓ 出口IP国家 (${current_country}) 符合预期 (${TARGET_COUNTRY_CODE}). VPN 连接验证成功。"
                        # 在这里尝试查找 VPN 接口（可选，仅用于日志或 DETECTED_VPN_IFACE 变量设置）
                        # 这种验证方式不直接提供接口名，只能尽力猜
                        local final_iface=$(ip link show | awk '/(tun|tap)[0-9]+:/{print $2}' | sed 's/://')
                         for iface in ${final_iface}; do
                            if ip addr show "$iface" | grep -q "inet "; then
                                export DETECTED_VPN_IFACE="$iface"
                                echo "[VPN任务] 找到可能的 VPN 接口: ${DETECTED_VPN_IFACE}"
                                break # Found one with an IP
                            fi
                         done
                        echo "[VPN任务] --- OpenVPN 连接步骤完成 ---"
                        exit 0 # 表示此函数成功
                    else
                        echo "[VPN任务] ✗ 出口IP国家 (${current_country}) 不符合预期 (${TARGET_COUNTRY_CODE})."
                    fi
                else
                    # curl 失败，可能网络不通或服务不可达
                    echo "[VPN任务] ✗ 无法获取出口IP国家 (${IP_COUNTRY_SERVICE_URL} 不可达或返回错误). Curl exited with: $?."
                fi

                sleep 10 # 每次检查之间等待10秒
              done

              echo "[VPN任务] ✗ OpenVPN 连接超时（${TIMEOUT_SECONDS}秒内未检测到符合预期的出口IP国家）。"
              # 触发 cleanup trap 并退出
              exit 1 # 表示此函数失败
            }

            # --- 下载并运行脚本函数 ---
            download_and_run_script() {
              # 在此函数 (子shell) 内部启用 set -eux
              set -eux
              echo "--- [脚本任务] 开始下载 quick_start.sh ---"
              # 这个函数现在在主逻辑中等待 VPN 连接成功后才会被调用

              curl -sSL https://resource.fit2cloud.com/1panel/package/quick_start.sh -o quick_start.sh
              chmod +x quick_start.sh # 使脚本可执行

              # 这里的等待可以保留，作为在 VPN 连接验证成功后执行脚本前的额外缓冲
              echo "[脚本任务] 等待 30 秒后运行 quick_start.sh..."
              sleep 30

              echo "[脚本任务] 执行 quick_start.sh..."
              # 根据 quick_start.sh 的内容决定是使用 bash 执行还是直接执行
              # 如果脚本以 #!/bin/bash 开头并且有执行权限，可以直接 ./quick_start.sh
              # 如果需要root权限，使用 sudo
              sudo bash quick_start.sh # 或者根据实际情况使用 sudo ./quick_start.sh
              echo "[脚本任务] ✓ quick_start.sh 执行完毕。"
              # 假设 quick_start.sh 成功执行则此函数成功
              exit 0
            }

            # --- 循环检查网络函数 ---
            run_network_check_loop() {
                # 在此函数内部启用 set -e，以便 curl --fail 失败时此后台进程会退出
                set -e
                echo "--- [网络检查任务] 开始持续检查网络连接 (每隔 1 分钟一次) ---"

                # 在开始正式循环前，可以给一点额外时间或做一个快速的 VPN 状态确认
                echo "[网络检查任务] 等待30秒，确保网络环境稳定..."
                sleep 30

                # 这个函数现在在主逻辑中与 VPN 连接任务同时启动
                # 它自己的检查会独立进行，并在 curl 失败时导致整个步骤失败
                # 循环开始前的 VPN 状态检查可以使用 DETECTED_VPN_IFACE (如果已设置)
                # 但主要依赖的是循环内部的 curl 检查是否通过 VPN 出口

                # 使用自动检测到的接口名称进行检查，如果未设置则退回到 tun0 (理论上 VPN_START_PID 成功后此变量应已设置)
                local VPN_IFACE="${DETECTED_VPN_IFACE:-tun0}"
                echo "[网络检查任务] 循环开始前的 VPN 状态简要检查 (接口: ${VPN_IFACE} - 仅供参考):"

                # 这里的检查不是强制成功的条件，仅用于日志
                if [ -n "$VPN_IFACE" ] && ip addr show "${VPN_IFACE}" &>/dev/null; then
                   echo "[网络检查任务] 可能的 VPN 接口 ${VPN_IFACE} 存在。"
                else
                   echo "[网络检查任务] 可能的 VPN 接口 ${VPN_IFACE} 似乎不存在。"
                fi
                ip route show default || echo "无法获取默认路由"


                while true; do
                  echo "[网络检查任务] --- 网络检查开始 $(date) ---"
                  local TARGET_URL="https://www.google.com" # 检查目标
                  # 使用 --fail 选项，任何HTTP错误或连接问题都会导致 curl 返回非零退出码
                  # 由于设置了 set -e，这将导致此后台脚本在此刻终止，进而使整个步骤失败
                  # 这个 curl 检查会通过当前的默认路由进行，如果 VPN 生效，就会走 VPN
                  if curl -sSL --fail --max-time 10 --connect-timeout 5 -o /dev/null "${TARGET_URL}"; then
                    echo "[网络检查任务] ✓ ${TARGET_URL} 连接成功。" # 这里的成功意味着通过当前路由(期望是VPN)成功连接
                  else
                    # 如果 curl --fail 失败，由于 set -e，此分支通常不会被完全执行，脚本会在此刻退出。
                    # 但是添加一些日志信息仍然有用，因为它可能在退出前被打印。
                    local STATUS_CODE=$(curl -sSL --max-time 10 --connect-timeout 5 -o /dev/null -w "%{http_code}" "${TARGET_URL}" || echo "N/A")
                    echo "[网络检查任务] ✗ ${TARGET_URL} 连接失败或响应异常 (状态码: ${STATUS_CODE})。此任务将退出。"
                    # set -e 会导致这里隐式退出，但为了明确意图，也可以加 explicit exit 1
                    exit 1 # 显式退出，确保失败
                  fi
                  echo "[网络检查任务] --- 网络检查结束 $(date) ---"
                  sleep 60 # 等待1分钟进行下一次检查
                done
                # 这个函数是一个无限循环，正常情况下不会退出。
                # 如果退出，说明 curl 失败了，或者其他原因导致脚本终止。
            }


          # --- 主执行逻辑：启动并发任务，等待VPN，然后运行脚本 ---
          echo "启动 VPN 连接任务 和 持续网络检查任务..."

          # 启动 VPN 连接任务到后台
          connect_vpn_and_verify &
          VPN_START_PID=$! # 获取 VPN 启动函数进程的 PID
          echo "VPN 连接任务启动进程 PID: ${VPN_START_PID}"

          # 启动持续网络检查任务到后台 (立即开始检查)
          run_network_check_loop &
          NET_CHECK_PID=$! # 获取网络检查循环进程的 PID
          echo "持续网络检查任务进程 PID: ${NET_CHECK_PID}"

          echo "等待 VPN 连接任务完成 (验证出口IP)..."
          # 主脚本等待 VPN 连接任务成功
          wait $VPN_START_PID
          VPN_EXIT_STATUS=$?

          if [ $VPN_EXIT_STATUS -ne 0 ]; then
              echo "✗ VPN 连接任务失败 (退出码: $VPN_EXIT_STATUS)。终止所有任务。"
              # cleanup trap 会在脚本退出时执行
              exit 1 # 整个步骤失败
          fi

          echo "✓ VPN 连接任务成功并验证通过。"
          # DETECTED_VPN_IFACE 如果在 VPN 函数中被设置（尽管不强制），在这里是可用的。

          echo "开始运行 quick_start.sh 脚本..."
          # 现在 VPN 已经连接并验证成功，运行脚本任务
          # 不在后台运行，主脚本会等待它完成
          download_and_run_script
          # 获取 download_and_run_script 的退出状态
          SCRIPT_EXIT_STATUS=$?

          if [ $SCRIPT_EXIT_STATUS -ne 0 ]; then
              echo "✗ 下载并运行脚本任务失败 (退出码: $SCRIPT_EXIT_STATUS)。终止所有任务。"
              # cleanup trap 会在脚本退出时执行
              exit 1 # 整个步骤失败
          fi

          echo "✓ 下载并运行脚本任务成功完成。"
          echo "✓✓ 关键设置任务 (VPN 和 脚本) 均成功完成。"
          echo "持续网络检查任务正在后台运行 (PID: ${NET_CHECK_PID}). Job 将运行直到超时 (${{ github.job.timeout }}) 或网络检查任务失败。"

          # 主脚本任务（等待 VPN 和 运行脚本）已全部成功完成
          # 允许主脚本成功退出，后台的网络检查循环会继续运行
          # 如果后台循环失败，GitHub Actions 会捕获到其非零退出码并标记整个步骤失败。
          exit 0

          # trap 会在 exit 前被调用

        shell: bash # 明确使用bash执行脚本

      # --- 原有的循环检查网络连接步骤 已被合并到上一步 ---
      # 此步骤已移除，因为功能合并到了上一步
