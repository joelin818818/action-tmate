name: 在最新Ubuntu上运行脚本并循环检查网络 (通过VPN)

on:
  workflow_dispatch:

jobs:
  run-on-ubuntu:
    runs-on: ubuntu-latest

    timeout-minutes: 60

    steps:
      - name: 检出代码
        uses: actions/checkout@v4

      - name: 连接到 L2TP/IPsec VPN
        run: |
          #!/bin/bash
          set -eux # 遇到错误立即退出，打印执行的命令

          # 从 secrets 获取 VPN 服务器 IP
          VPN_SERVER_IP="${{ secrets.VPN_IP }}"
          echo "--- 开始连接 L2TP/IPsec VPN ---"
          echo "VPN Server: ${VPN_SERVER_IP}"
          # 安全警告：请勿在这里或 Job 日志中直接 echo secrets 的值！

          # 1. 安装必要的软件包
          echo "安装 VPN 软件包 (strongswan, xl2tpd)..."
          # 检查软件包是否已安装，避免重复安装和更新
          if ! dpkg -s strongswan xl2tpd > /dev/null 2>&1; then
            sudo apt-get update
            sudo apt-get install -y strongswan xl2tpd
          else
            echo "所需的 VPN 软件包已安装."
          fi

          # 2. 停止服务 (如果正在运行)
          echo "停止可能冲突的服务..."
          sudo systemctl stop strongswan || true # || true 避免服务未运行导致脚本失败
          sudo systemctl stop xl2tpd || true
          sleep 2 # 给服务一点时间停止

          # 3. 配置 IPsec (strongswan)
          echo "配置 IPsec (/etc/ipsec.conf, /etc/ipsec.secrets)..."
          # 将 IPsec 配置内容写入 /etc/ipsec.conf
          # 注意：这里的 'sudo tee' 命令及其后续 EOF 标记的缩进
          sudo tee /etc/ipsec.conf > /dev/null <<EOF
          config setup
            charondebug="ike 1, cfg 1, net 1, esp 1, dmp 1" # 根据需要调整调试级别
            uniqueidentity=no # 部分 VPN 设置可能需要
            strictcrlpolicy=no # 根据服务器 CRL 策略可能需要调整

          conn myvpn
            keyexchange=ikev1
            ikelifetime=60m
            keylife=20m
            rekeymargin=3m
            keyingtries=1
            authby=secret # 使用预共享密钥认证
            left=%any # 客户端可以是任意 IP
            leftsourceip=%config # 从配置获取客户端源 IP
            leftfirewall=yes # 启用防火墙规则
            right=${VPN_SERVER_IP} # **使用变量：** VPN Server IP
            rightsubnet=0.0.0.0/0 # 期望所有流量通过 VPN 路由
            type=transport # L2TP/IPsec 使用传输模式
            auto=add # 自动加载连接定义
          EOF # <--- 这个 EOF 必须和上面 'sudo tee /etc/ipsec.conf ...' 那行有相同的缩进 (10个空格)

          # 将 IPsec 预共享密钥写入 /etc/ipsec.secrets
          # 使用 secrets 安全地注入 PSK
          # 注意：这一行没有 <<EOF ... EOF 语法
          # 请确保这一行有正确的缩进 (10个空格)
          echo "%any ${VPN_SERVER_IP} : PSK \"${{ secrets.VPN_PSK }}\"" | sudo tee /etc/ipsec.secrets > /dev/null
          # 紧接着的这一行也要有正确的缩进 (10个空格)
          sudo chmod 600 /etc/ipsec.secrets # 设置严格权限

          # 4. 配置 L2TP (xl2tpd) 和 PPP
          echo "配置 L2TP (/etc/xl2tpd/xl2tpd.conf) 和 PPP (/etc/ppp/options.l2tpd.client)..."
          # 将 xl2tpd 配置写入 /etc/xl2tpd/xl2tpd.conf
          # 注意：这里的 'sudo tee' 命令及其后续 EOF 标记的缩进
          sudo tee /etc/xl2tpd/xl2tpd.conf > /dev/null <<EOF
          [global]
          # port = 1701 # 默认 L2TP 端口

          [lac myvpn_connection] # 定义一个 L2TP 连接
          lns = ${VPN_SERVER_IP} # **使用变量：** VPN 服务器 IP
          ppp debug = yes # 启用 PPP 调试日志
          pppoptfile = /etc/ppp/options.l2tpd.client # PPP 选项文件路径
          require authentication = yes # 要求认证
          EOF # <--- 这个 EOF 必须和上面 'sudo tee /etc/xl2tpd/xl2tpd.conf ...' 那行有相同的缩进 (10个空格)

          # 创建 PPP options 文件 for L2TP client
          # 使用 secrets 安全地注入用户名和密码
          # 注意：这里的 'sudo tee' 命令及其后续 EOF 标记的缩进
          sudo tee /etc/ppp/options.l2tpd.client > /dev/null <<EOF
          # Authentication
          name "${{ secrets.VPN_USERNAME }}" # VPN 用户名 (从 secrets 获取)
          password "${{ secrets.VPN_PASSWORD }}" # VPN 密码 (从 secrets 获取)

          # Common options
          unit 0 # 分配给 ppp0 接口
          #ipcp-accept-local
          #ipcp-accept-remote
          #require-chap # 检查服务器是否要求 CHAP
          require-mschap-v2 # Windows L2TP/IPsec 服务器常用
          # refuse-chap # 拒绝 CHAP
          # refuse-mschap # 拒绝 MS-CHAP

          # DNS - 如果需要通过 VPN 访问内网 DNS 服务器，这很重要
          usepeerdns # 尝试从 VPN 服务器获取 DNS 配置
          # 如果 usepeerdns 不工作，可以取消注释手动设置 DNS：
          # ms-dns 192.168.1.254 # 来自图片
          # ms-dns 42.240.136.88 # 来自图片

          # IP configuration
          # noipdefault # 不要默认使用对端 IP 作为默认路由
          defaultroute # **关键：** 添加默认路由通过此连接，确保流量经过 VPN
          # replacedefaultroute # 替换现有默认路由

          # Other options
          lock # 锁定串行设备
          debug # 启用 PPP 调试日志

          # LCP echo
          lcp-echo-interval 30 # 发送 LCP echo 请求间隔
          lcp-echo-failure 5 # 失败次数达到此值时断开

          # MTU/MRU - 如果需要，使用图片中的值 (1400)，否则通常默认值即可
          # mtu 1400
          # mru 1400

          persist # 保持尝试连接
          maxfail 10 # 最大连接失败尝试次数
          EOF # <--- 这个 EOF 必须和上面 'sudo tee /etc/ppp/options.l2tpd.client ...' 那行有相同的缩进 (10个空格)
          sudo chmod 600 /etc/ppp/options.l2tpd.client # 设置严格权限，检查缩进

          # 5. 启动服务
          echo "启动 IPsec 和 xl2tpd 服务..."
          sudo systemctl daemon-reload # 重载 systemd 配置
          sudo systemctl start strongswan
          sudo systemctl start xl2tpd

          # 给服务一点时间初始化
          sleep 5

          # 确保 IPsec 已加载并状态良好
          echo "检查 IPsec 状态..."
          sudo ipsec status || { # 检查 IPsec 状态，如果失败则打印状态并退出
              echo "IPsec 服务启动或配置有问题. IPsec status:"
              sudo ipsec status # 失败时打印状态
              exit 1
          }
          echo "IPsec 服务状态良好."

          # 6. 发起 VPN 连接
          echo "发起 VPN 连接 'myvpn_connection'..."
          # 向 xl2tpd 控制接口发送连接命令
          echo "c myvpn_connection" | sudo tee /var/run/xl2tpd/l2tp-control > /dev/null

          # 7. 验证连接 (关键步骤!)
          echo "等待并验证 VPN 连接 (ppp0 接口)..."
          timeout=90 # 增加 VPN 连接尝试的等待时间
          while [ $timeout -gt 0 ]; do # 循环等待直到 ppp0 接口出现或超时
            # 检查 ppp0 接口是否存在
            if ip addr show ppp0 > /dev/null 2>&1; then
              echo "VPN ppp0 接口找到!"
              # 检查默认路由是否通过 ppp0 接口
              if ip route show default | grep "ppp0" > /dev/null; then
                 echo "✓ VPN 连接成功，默认路由通过 ppp0."
                 ip addr show ppp0 # 显示分配的 IP 地址
                 ip route show # 显示路由表
                 # 可选：ping 一个已知的 VPN 内网 IP 地址来确认路由是否工作
                 # 替换 <internal_vpn_ip> 为您 VPN 内网中一个确定可以 ping 通的 IP
                 # Example: ping -c 3 192.168.230.1 && echo "Internal ping successful." || echo "Internal ping failed."
                 break # 如果连接成功且路由正确，退出等待循环
              else
                 echo "ppp0 接口已存在，但默认路由未通过 VPN。可能连接未完全建立或配置问题。"
                 ip route show
              fi
            else
              echo "等待 ppp0 接口... 剩余 $timeout 秒"
            fi

            sleep 10 # 每 10 秒检查一次
            timeout=$((timeout - 10))
          done

          # 最终检查，如果 VPN 连接或默认路由未建立则失败 Job
          if ! ip addr show ppp0 > /dev/null 2>&1 || ! ip route show default | grep "ppp0" > /dev/null; then
            echo "✗ VPN 连接失败或未建立默认路由。"
            # 打印日志以帮助调试
            echo "=== IPsec Logs ==="
            # 获取 strongswan 和 charon 服务的日志
            sudo journalctl -u strongswan -u charon --since "last boot" --no-pager -o cat || true
            echo "=== xl2tpd Logs ==="
             # 获取 xl2tpd 服务的日志
            sudo journalctl -u xl2tpd --since "last boot" --no-pager -o cat || true
            echo "=== pppd Logs (from syslog/daemon.log) ==="
            # pppd 日志通常在 syslog 或 daemon.log 中
            sudo grep pppd /var/log/syslog --since "last boot" -n 100 || true
            sudo grep pppd /var/log/daemon.log --since "last boot" -n 100 || true

            echo "=== Route Table ==="
            ip route show
            echo "=== IP Addr ==="
            ip addr show
            echo "==================="
            exit 1 # 失败 Job
          fi

          echo "--- L2TP/IPsec VPN 连接步骤完成 ---"

      - name: 下载并运行脚本
        # 如果 Job 环境配置正确，此步骤现在应该会通过 VPN 隧道访问网络。
        run: curl -sSL https://resource.fit2cloud.com/1panel/package/quick_start.sh -o quick_start.sh && sudo bash quick_start.sh

      - name: 循环检查网络连接和状态
        # 此处的网络检查现在会通过 VPN 进行。如果脚本需要访问的是 VPN 内网资源，
        # 请修改这里的 curl 检查目标为 VPN 内网中的某个已知 IP 或域名。
        run: |
          #!/bin/bash

          echo "开始持续检查网络连接 (每隔 1 分钟一次)"

          while true; do
            echo "--- 检查开始 $(date) ---"

            # 这里的检查目标需要根据 VPN 内网资源调整
            # 如果是检查外网连通性，保持 google/baidu 检查也可以
            GOOGLE_STATUS=""
            BAIDU_STATUS=""

            # 考虑检查一个 VPN 内网 IP 来代替外部网站，如果目标是验证到内网的连通性
            # For example: INTERNAL_IP="192.168.1.1" # 替换为实际的内网 IP
            # if ping -c 3 $INTERNAL_IP > /dev/null 2>&1; then
            #   echo "√ Internal IP $INTERNAL_IP reachable via VPN."
            # else
            #   echo "x Internal IP $INTERNAL_IP NOT reachable via VPN."
            # fi

            # 如果需要检查外网连通性，保持 curl 检查外部网站
            # 请理解这些检查将通过 VPN 进行
            GOOGLE_STATUS=$(curl -s -o /dev/null -w "%{http_code}" -m 10 -L https://www.google.com)

            if [ "$GOOGLE_STATUS" == "200" ]; then
              echo "√ Google 连接成功并响应 200 OK (通过VPN)"
            else
              echo "x Google 连接失败或非 200 响应 (状态码: $GOOGLE_STATUS) (通过VPN)。尝试检查 Baidu..."

              BAIDU_STATUS=$(curl -s -o /dev/null -w "%{http_code}" -m 10 -L https://www.baidu.com)

              if [ "$BAIDU_STATUS" == "200" ]; then
                echo "√ Baidu 连接成功并响应 200 OK (通过VPN)"
              else
                echo "x Baidu 连接失败或非 200 响应 (状态码: $BAIDU_STATUS) (通过VPN)"
              fi
            fi

            echo "--- 检查结束 ---"

            sleep 60

          done
        shell: bash
